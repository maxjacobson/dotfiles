#!/usr/bin/env ruby

require 'json'
require 'time'
require 'readline'
require 'shellwords'

class Login
  def initialize(name:, username:, password:, created_at:, updated_at:)
    @name = name
    @username = username
    @password = password
    @created_at = Time.at(created_at)
    @updated_at = Time.at(updated_at)
  end

  def to_s
    "#{name} - #{username}"
  end

  def to_s_with_password
    if system("echo #{password.shellescape} | pbcopy")
      "On clipboard! Username is #{username}"
    else
      puts "Boo... could not copy..."
    end
  end

  def <=>(other)
    name <=> other.name
  end

  attr_reader :name

  private

  attr_reader :username, :password, :created_at, :updated_at
end

logins =
  begin
    JSON.parse(`rooster export`).map { |login|
      Login.new(
        name: login.fetch("name"),
        username: login.fetch("username"),
        password: login.fetch("password"),
        created_at: login.fetch("created_at"),
        updated_at: login.fetch("updated_at"),
      )
    }
  rescue JSON::ParserError
    exit 1
  rescue Interrupt
    exit 1
  end

class App
  def initialize(logins)
    @logins = logins.sort
  end

  def start
    loop do
      get_input
      process_input if validate_input
    end
  end

  def get(name)
    login = @logins.detect { |login| login.name == name }
    if login
      puts login.to_s_with_password
    else
      puts "No login with name #{name}"
    end
  end

  def list
    @logins.each do |login|
      puts login
    end
  end

  private

  attr_reader :logins

  def get_input
    Readline.readline("> ").tap do |input|
      if input.nil?
        @input = []
      else
        words = input.split(" ")
        args = words[1..-1]
        if !args.empty?
          args = args.join(" ")
        end
        @input = [words.first, args]
      end
    end
  rescue Interrupt
    @input = []
  end

  def valid_inputs
    %w[list get]
  end

  def validate_input
    if @input.empty?
      exit 1
    end

    if !valid_inputs.include?(@input.first)
      puts "bad command: #{@input.first}. Valid commands: #{valid_inputs}"
      return false
    end

    true
  end

  def process_input
    public_send @input.first, *@input.last
  rescue ArgumentError
    puts "Bad arguments to #{@input.first}"
  end
end

app = App.new(logins)
app.start
